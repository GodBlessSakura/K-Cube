{% extends "layout.html" %}
{% import 'layout.html' as layout with context %}
{% block VueComponent %}
<v-card style="height: 100%; width: 100%;">
    <div id="cy" style="height: 100%; width: 100%;"></div>
    <v-snackbar v-model="showSelectBar" timeout='-1'>
        Select a ${ (snackbarMethod == 'branch' || snackbarMethod == 'workspace')?'a branch or a trunk':'ready branch'}
        for ${
        (snackbarMethod == 'branch')?'merging':(snackbarMethod == 'workspace')?'checkout':'creation'}
        <template v-slot:action="{ attrs }">
            <v-btn color="blue" text v-bind="attrs" @click="resume()">
                Cancel
            </v-btn>
        </template>
    </v-snackbar>
    <v-menu v-model="showMenu" :position-x="cursor_x" :position-y="cursor_y" absolute>
        <v-list>
            <v-subheader>${_selectedNode?.data('tag')}</v-subheader>
            <v-divider> </v-divider>
            {% if isInstructor %}
            <v-subheader v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">status
            </v-subheader>
            <v-list-item v-if="selectedNodeClasses.includes('isOwner')" @click="toggleExposure()">
                <v-list-item-title>Toggle exposure</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('isOwner')" @click="readyToPush()">
                <v-list-item-title>Toggle ready-to-pull</v-list-item-title>
            </v-list-item>
            <v-divider v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">
            </v-divider>
            <v-subheader v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">
                versioning</v-subheader>
            <v-list-item v-if="selectedNodeClasses.includes('branch')" @click="mergeWithAnother()">
                <v-list-item-title>Merge with another</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')"
                @click="newTab('{{ url_for('instructor.graphimport')}}' + _selectedNode?.data('deltaGraphId'))">
                <v-list-item-title>Import graph</v-list-item-title>
            </v-list-item>
            <v-divider v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">
            </v-divider>
            <v-subheader>workspaces</v-subheader>
            <v-list-item v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')"
                @click="createWorkspaceDialogue()">
                <v-list-item-title>Create workspace</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('workspace')" @click="commit()">
                <v-list-item-title>Commit workspace</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('workspace')" @click="checkout()">
                <v-list-item-title>Checkout different graph</v-list-item-title>
            </v-list-item>
            {% endif %}
            {% if isDLTC %}
            <v-list-item v-if="selectedNodeClasses.includes('trunk') && !selectedNodeClasses.includes('isActive')"
                @click="setActive()">
                <v-list-item-title>Set as active</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('trunk')" @click="release()">
                <v-list-item-title>Release new version</v-list-item-title>
            </v-list-item>
            {% endif %}
        </v-list>
    </v-menu>
    {% if isInstructor %}
    <v-dialog v-model="workspaceCreateDialog">
        <v-card>
            <v-card-title class="text-h5 grey lighten-2">
                Give a name tag to your new workspace:
            </v-card-title>
            <v-form ref="createWorkspaceControl">
                <v-text-field label="tag" :rules="tagRules" v-model="tag" required></v-text-field>
            </v-form>
            <v-divider></v-divider>

            <v-card-actions>
                <v-spacer></v-spacer>
                <v-btn color="primary" text @click="createWorkspace()">
                    create
                </v-btn>
            </v-card-actions>
        </v-card>
    </v-dialog>
    {% endif %}
</v-card>
{% endblock %}
{% block VueComponentScript %}
{{ layout.cytoscapeCDN() }}
<script>
    cy = cytoscape({
        style: [{
                selector: 'node',
                style: {
                    'label': 'data(tag)'
                }
            }, {
                selector: 'node.trunk',
                style: {
                    'shape': 'star'
                }
            }, {
                selector: 'node.isExposed',
                style: {
                    'background-color': 'green'
                }
            }, {
                selector: 'node.isActive',
                style: {
                    'background-color': 'red'
                }
            }, {
                selector: 'node.workspace',
                style: {
                    'shape': 'diamond'
                }
            }, {
                selector: 'node.workspace',
                style: {
                    'shape': 'triangle'
                }
            },
            {
                selector: 'edge',
                style: {
                    'label': 'data(tag)',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier'
                }
            },
            {
                selector: 'edge[tag="WORK_ON"]',
                style: {
                    'text-opacity': 0
                }
            },
            {
                selector: 'node.uselectable',
                style: {
                    'opacity': 0.25
                }
            }, {
                selector: 'node.branch',
                style: {
                    'shape': 'rectangle'
                }
            }, {
                selector: 'node.canPull',
                style: {
                    'shape': 'diamond'
                }
            },
        ],
        userZoomingEnabled: false,
        userPanningEnabled: false,
        boxSelectionEnabled: false
    })

    function nodeFactory(node, classes) {
        if (node.isActive) {
            classes.push('isActive')
        }
        if (node.canPatch) {
            classes.push('canPatch')
        }
        if (node.property.canPull) {
            classes.push('canPull')
        }
        if (node.isExposed) {
            classes.push('isExposed')
        }
        if (node.isOwner) {
            classes.push('isOwner')
        }
        let output = {
            group: 'nodes',
            data: {
                id: 'node' + node.id,
                tag: node.property.tag,
                deltaGraphId: node.property.deltaGraphId,
                creationDate: new Date(node.property.creationDate)
            },
            classes: classes,
            position: {
                x: 0,
                y: 0
            },
            grabbable: false,
            pannable: false,
            position: {
                x: 0,
                y: 0
            }
        }
        return output
    }

    function edgeFactory(edge) {
        let output = {
            group: 'edges',
            data: {
                id: 'edge' + edge.id,
                source: 'node' + edge.start,
                target: 'node' + edge.end,
                tag: edge.type
            }
        }
        return output

    }
    Vue.component('app-content', {
        data: () => ({
            showMenu: false,
            cursor_x: undefined,
            cursor_y: undefined,
            showSelectBar: false,
            snackbarMethod: '',
            _selectedNode: undefined, // this makes the vuetify not observing the object
            selectedNodeClasses: [],
            //{% if isInstructor %}
            workspaceCreateDialog: false,
            tag: '',
            tagRules: [v => !!v || 'Tag name is required',
                v => (v && v.length > 3 && v.length < 101) ||
                'Tag name should be anything between 4 and 100 charactors',
                v => (v && /{{regExpRules["tag"]}}/.test(v)) ||
                'Tag name can only contains alphanumeric characters, dot(.) and space.'
            ],
            //{% endif %}
        }),
        methods: {
            loadData() {
                this.$root.progress.show = true
                fetch(
                        "{{ url_for('RESTful.tree.get', courseCode = courseCode, isInstructor = isInstructor, isDLTC = isDLTC) }}", {
                            method: 'GET',
                            cache: 'no-store',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        })
                    .then(response => {
                        try {
                            return response.json()
                        } catch {
                            this.$root.progress.show = false
                            this.$root.errorDisplay({},
                                'Unexpected error occured.')
                        }
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.edges && body.trunk_nodes && body.branch_nodes && body.workspace_nodes) {
                            cy.remove(cy.elements())
                            body.trunk_nodes.forEach(node => {
                                cy.add(nodeFactory(node, ["trunk"]))
                            })
                            body.branch_nodes.forEach(node => {
                                cy.add(nodeFactory(node, ["branch"]))
                            })
                            body.workspace_nodes.forEach(node => {
                                cy.add(nodeFactory(node, ["workspace"]))
                            })
                            body.edges.forEach(edge => {
                                [edge.start, edge.end].forEach(id => {
                                    let node = cy.getElementById('node' + id)
                                    if (node.length == 0) {
                                        cy.add(nodeFactory({
                                            property: {
                                                tag: 'hidden'
                                            },
                                            id: id
                                        }, ["invisible"]))
                                    }
                                })

                                cy.add(edgeFactory(edge))
                            })
                            cy.layout({
                                name: 'breadthfirst',
                                fit: true,
                                grid: true,
                                roots: 'node[tag = "init"]',
                                padding: document.documentElement.clientHeight * 0.15
                            }).run()
                            let root = cy.nodes('[tag = "init"]')
                            let stepX = 200
                            let stepY = 200

                            function locatePredecessorsX(node) {
                                let thickness = 0
                                let position = node.position()
                                let forkEdges = node.incomers('edge[tag="FORK"]').sort((edgeA, edgeB) => {
                                    let childA = edgeA.source()
                                    let childB = edgeB.source()
                                    return childA.data('creationDate') - childB.data('creationDate')
                                })
                                let patchEdges = node.incomers('edge[tag="PATCH"]').sort((edgeA,
                                    edgeB) => {
                                    let childA = edgeA.source()
                                    let childB = edgeB.source()
                                    return childA.data('creationDate') - childB.data('creationDate')
                                })
                                patchEdges.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        x: position.x,
                                    })
                                    thickness = Math.max(thickness, locatePredecessorsX(child))
                                })
                                forkEdges.forEach(edge => {
                                    thickness++
                                    let child = edge.source()
                                    child.position({
                                        x: position.x + stepX * thickness,
                                    })
                                    thickness += locatePredecessorsX(child)
                                })
                                return thickness
                            }

                            function locatePredecessorsY(node) {
                                let position = node.position()
                                let fixedEdges = node.incomers('edge[tag="PATCH"],edge[tag = "FORK"]')
                                // .filter(edge => {
                                //     let child = edge.source()
                                //     return child.outgoers(
                                //         'edge[tag = "BRANCH_PULL"],edge[tag = "TRUNK_PULL"]'
                                //     ).length == 0
                                // });
                                let pulledEdge = node.incomers(
                                    'edge[tag="BRANCH_PULL"],edge[tag = "TRUNK_PULL"]')
                                fixedEdges.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        y: Math.max(position.y + stepY, child.position().y),
                                    })
                                    let pulling = child.incomers(
                                        'edge[tag = "BRANCH_PULL"],edge[tag = "TRUNK_PULL"]'
                                    )
                                    if (pulling.length > 0) {
                                        pulling.map(edge => edge.source()).forEach(puller => {
                                                puller.position({
                                                    y: child.position().y + stepY,
                                                })
                                                locatePredecessorsY(puller)
                                            }

                                        )
                                    }
                                })
                                pulledEdge.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        y: Math.max(position.y + stepY, child.position().y),
                                    })
                                    locatePredecessorsY(child)
                                })
                                fixedEdges.forEach(edge => {
                                    let child = edge.source()
                                    locatePredecessorsY(child)
                                })
                            }

                            function locateWorkspace(node) {
                                let j = Math.PI * 0.75
                                let position = node.position()
                                let workEdges = node.incomers('edge[tag="WORK_ON"]').sort((edgeA,
                                    edgeB) => {
                                    let childA = edgeA.source()
                                    let childB = edgeB.source()
                                    return childA.data('creationDate') - childB.data('creationDate')
                                })
                                workEdges.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        x: position.x + 75 * Math.cos(j),
                                        y: position.y + 75 * Math.sin(j)
                                    })
                                    j = j + Math.PI / 4;
                                })
                                node.incomers('edge[tag!="WORK_ON"]').forEach(edge => {
                                    let child = edge.source()
                                    locateWorkspace(child)
                                })
                            }
                            locatePredecessorsX(root)
                            locatePredecessorsY(root)
                            locateWorkspace(root)
                            cy.fit()
                        } else {
                            this.$root.errorDisplay(body,
                                'Unexpected error on getting versions information.')
                        }
                    })
            },
            // {% if isInstructor %}
            readyToPush() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                fetch("{{ url_for('RESTful.branch.patch') }}" + this._selectedNode.data("deltaGraphId"), {
                        method: 'PATCH',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            canPull: !this._selectedNode.classes().includes("canPull")
                        })
                    })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        this.$root.responseSnackBar(body,
                            'Creation failed for unknown reason.',
                            () => {
                                this.loadData()
                            })
                    })
            },
            toggleExposure() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                let isExposed = this._selectedNode.classes().includes("isExposed") ? false : true
                fetch("{{ url_for('RESTful.branch.patch') }}" + this._selectedNode.data("deltaGraphId"), {
                        method: 'PATCH',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            isExposed: isExposed,
                        })
                    })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        this.$root.responseSnackBar(body,
                            'Creation failed for unknown reason.',
                            () => {
                                this.loadData()
                            })
                    })

            },
            mergeWithAnother() {
                this.snackbarMethod = 'branch'
                this.selectableNodes = cy.nodes(
                    '.branch[deltaGraphId  != "' + this._selectedNode.data("deltaGraphId") + '"],' +
                    '.trunk')
                this.selectAnotherMode()
            },
            checkout() {
                this.snackbarMethod = 'workspace'
                this.selectableNodes = cy.nodes('.branch,.trunk')
                this.selectAnotherMode()
            },
            createWorkspaceDialogue() {
                this.workspaceCreateDialog = true
            },
            createWorkspace() {
                if (this.$refs.createWorkspaceControl.validate()) {
                    if (this.$root.progress.show == true) {
                        this.$root.bePatientSnackBar.show = true
                        return
                    }
                    this.$root.progress.show = true
                    fetch("{{ url_for('RESTful.workspace.post') }}" + this._selectedNode.data("deltaGraphId"), {
                            method: 'POST',
                            cache: 'no-store',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                tag: this.tag,
                            })
                        })
                        .then(response => {
                            return response.json()
                        })
                        .then(body => {
                            this.$root.progress.show = false
                            this.$root.responseSnackBar(body,
                                'Creation failed for unknown reason.',
                                () => {
                                    this.workspaceCreateDialog = false
                                    this.$refs.createWorkspaceControl.reset()
                                    this.loadData()
                                })
                        })
                }
            },
            commit() {
                this.newTab("{{ url_for('instructor.commit')}}" + this._selectedNode.data("deltaGraphId"))
            },
            // {% endif %}
            // {% if isDLTC %}
            setActive() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                fetch("{{ url_for('RESTful.trunk.patch') }}" + this._selectedNode.data("deltaGraphId"), {
                        method: 'PATCH',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            active: true,
                        })
                    })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        this.$root.responseSnackBar(body,
                            'Creation failed for unknown reason.',
                            () => {
                                this.loadData()
                            })
                    })
            },
            release() {
                this.snackbarMethod = 'trunk'
                this.selectableNodes = cy.nodes(
                    '.branch.canPull')
                this.selectAnotherMode()
            },
            // {% endif %}
            selectAnotherMode() {
                cy.nodes().difference(this.selectableNodes).addClass('uselectable')
                cy.nodes().unselectify()
                this.showSelectBar = true
            },
            resume() {
                this.showSelectBar = false
                cy.nodes(".uselectable").removeClass('uselectable')
                cy.nodes().unselectify()
            },
            newTab(url) {
                let w = window.open(url, '_blank')
                w.onbeforeunload = () => {
                    this.loadData()
                }
                w.focus()
                this.resume()
            }
        },
        mounted: function () {
            cy.mount(document.getElementById("cy"))
            cytoscapeInstance.forEach(instance => {
                instance.cy.container().style.background = cyStyles[instance.options].filter(
                    sheet => sheet.selector == 'background-color')[0].style["background-color"]
            })
            window.onresize = () => {
                cy.fit()
            }
            self = this
            cy.on('cxttapend', 'node', (event) => {
                console.log(event)
                if (event.target == event.cy) return
                self.showMenu = true
                self.cursor_x = event.originalEvent.clientX
                self.cursor_y = event.originalEvent.clientY
                this._selectedNode = event.target[0]
                this.selectedNodeClasses = event.target[0].classes()
                cy.nodes().unselect()
                cy.edges().unselect()
                event.target[0].select()
            })
            cy.on('tap', 'node', (event) => {
                console.log(event)
                if (event.target == event.cy) return
                if (this.showSelectBar) {
                    // {% if isInstructor %}
                    if (this.snackbarMethod == 'branch') {
                        if (this.selectableNodes.contains(event.target[0])) {
                            this.newTab("{{ url_for('instructor.branch')}}" + event.target[0].data(
                                    'deltaGraphId') + '/' + this
                                ._selectedNode.data("deltaGraphId"))
                        }
                    }
                    if (this.snackbarMethod == 'workspace') {
                        if (this.selectableNodes.contains(event.target[0])) {
                            fetch("{{ url_for('RESTful.workspace.patch') }}" + this
                                    ._selectedNode.data("deltaGraphId"), {
                                        method: 'PATCH',
                                        cache: 'no-store',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            checkout: true,
                                            deltaGraphId: event.target[0].data(
                                                'deltaGraphId')
                                        })
                                    })
                                .then(response => {
                                    try {
                                        return response.json()
                                    } catch {
                                        this.$root.progress.show = false
                                        this.$root.errorDisplay({},
                                            'Unexpected error occured.')
                                    }
                                })
                                .then(body => {
                                    this.$root.progress.show = false
                                    this.$root.responseSnackBar(body,
                                        'Sync failed for unknown reason.',
                                        () => {
                                            this.loadData()
                                        })
                                })
                        }
                    }
                    // {% endif %}
                    // {% if isDLTC %}
                    if (this.snackbarMethod == 'trunk') {
                        if (this.selectableNodes.contains(event.target[0])) {
                            this.newTab("{{ url_for('DLTC.trunk')}}" + event.target[0].data(
                                    'deltaGraphId') + '/' + this
                                ._selectedNode.data("deltaGraphId"))
                        }
                    }
                    // {% endif %}
                    return
                }
                if (event.target.classes().includes("trunk")) {
                    let parent = event.target[0].connectedEdges(
                        '[tag = "FORK"],[tag = "PATCH"]').targets('[id != "' + event.target[
                            0]
                        .data('id') + '"]')
                    if (parent.length == 0) {
                        this.newTab("{{ url_for('collegue.graphView')}}" + event.target[0].data(
                            'deltaGraphId'))
                    } else {
                        this.newTab("{{ url_for('collegue.compare')}}" + event.target[0].data(
                            'deltaGraphId') + '/' + parent.data('deltaGraphId'))
                    }
                }
                if (event.target.classes().includes("branch")) {
                    let parent = event.target[0].connectedEdges(
                        '[tag = "FORK"],[tag = "PATCH"]').targets('[id != "' + event.target[
                            0]
                        .data('id') + '"]')
                    if (parent.length == 0) {
                        this.newTab("{{ url_for('collegue.graphView')}}" + event.target[0].data(
                            'deltaGraphId'))
                    } else {
                        this.newTab("{{ url_for('collegue.compare')}}" + event.target[0].data(
                            'deltaGraphId') + '/' + parent.data('deltaGraphId'))
                    }
                }
                // {% if isInstructor %}
                if (event.target.classes().includes("workspace")) {
                    this.newTab("{{ url_for('instructor.workspace')}}" + event.target.data(
                        "deltaGraphId"))
                }
                // {% endif %}
                // {% if isDLTC %}
                // {% endif %}
            })
            this.loadData()
        },
        template: '#content',
        delimiters: ['${', '}'],
    })
</script>
{% endblock %}