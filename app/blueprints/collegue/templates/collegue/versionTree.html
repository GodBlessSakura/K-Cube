{% extends "layout.html" %}
{% import 'layout.html' as layout with context %}
{% block VueComponent %}
<v-card style="height: 100%; width: 100%;">
    <v-container style="height: 100%; width: 100%;">
        <v-row style="height: 100%;">
            <v-col>
                <v-row style="height: 25%;">

                </v-row>
                <v-row style="height: 75%; border-top: 1px solid black">
                    <div v-if="url==''">
                        click on a node to view a version<br>
                        click on an edge to view the changes that an update has made
                    </div>
                    <iframe ref="iframe" style="height: 100%; width:100%" frameBorder="0" :src="url" scrolling="no">

                    </iframe>
                </v-row>
            </v-col>
            <v-col style="height: 100%; border-left: 1px solid black" cols="3">
                <div id="cy" style="height: 100%; width: 100%;"></div>
            </v-col>
        </v-row>
    </v-container>
    <v-snackbar v-model="showSelectBar" timeout='-1'>
        Select a ${ (snackbarMethod == 'branch' || snackbarMethod == 'workspace')?'a branch or a trunk':'ready branch'}
        for ${
        (snackbarMethod == 'branch')?'merging':(snackbarMethod == 'workspace')?'checkout':'creation'}
        <template v-slot:action="{ attrs }">
            <v-btn color="blue" text v-bind="attrs" @click="resume()">
                Cancel
            </v-btn>
        </template>
    </v-snackbar>
    <v-menu v-model="showMenu" :position-x="cursor_x" :position-y="cursor_y" absolute>
        <v-list>
            <v-subheader>${this._selectedNode?.data('tag')}</v-subheader>
            <v-divider> </v-divider>
            {% if request.blueprint == "instructor" %}
            <v-subheader v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">status
            </v-subheader>
            <v-list-item v-if="selectedNodeClasses.includes('isOwner')" @click="toggleExposure()">
                <v-list-item-title>Toggle exposure</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('isOwner')" @click="readyToPush()">
                <v-list-item-title>Toggle ready-to-pull</v-list-item-title>
            </v-list-item>
            <v-divider v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">
            </v-divider>
            <v-subheader v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">
                versioning</v-subheader>
            <v-list-item v-if="selectedNodeClasses.includes('branch')" @click="mergeWithAnother()">
                <v-list-item-title>Merge with another</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')"
                @click="newTab('{{ url_for('instructor.graphimport')}}' + _selectedNode?.data('deltaGraphId'))">
                <v-list-item-title>Import graph</v-list-item-title>
            </v-list-item>
            <v-divider v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')">
            </v-divider>
            <v-subheader>workspaces</v-subheader>
            <v-list-item v-if="selectedNodeClasses.includes('branch') || selectedNodeClasses.includes('trunk')"
                @click="createWorkspaceDialogue()">
                <v-list-item-title>Create workspace</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('workspace')" @click="commit()">
                <v-list-item-title>Commit workspace</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('workspace')" @click="checkout()">
                <v-list-item-title>Checkout different graph</v-list-item-title>
            </v-list-item>
            {% endif %}
            {% if request.blueprint == "DLTC" %}
            <v-list-item v-if="selectedNodeClasses.includes('trunk') && !selectedNodeClasses.includes('isActive')"
                @click="setActive()">
                <v-list-item-title>Set as active</v-list-item-title>
            </v-list-item>
            <v-list-item v-if="selectedNodeClasses.includes('trunk')" @click="release()">
                <v-list-item-title>Release new version</v-list-item-title>
            </v-list-item>
            {% endif %}
        </v-list>
    </v-menu>
    {% if request.blueprint == "instructor" %}
    <v-dialog v-model="workspaceCreateDialog">
        <v-card>
            <v-card-title class="text-h5 grey lighten-2">
                Give a name tag to your new workspace:
            </v-card-title>
            <v-form ref="createWorkspaceControl">
                <v-text-field label="tag" :rules="tagRules" v-model="tag" required></v-text-field>
            </v-form>
            <v-divider></v-divider>

            <v-card-actions>
                <v-spacer></v-spacer>
                <v-btn color="primary" text @click="createWorkspace()">
                    create
                </v-btn>
            </v-card-actions>
        </v-card>
    </v-dialog>
    {% endif %}
    <v-btn @click="setZoom(0.2)"
        style="position: absolute; right:5vw; bottom: 5vw; border-radius: 100px 100px 0px 0px; height: 50px; width:100px; transform: translate(+50%, -50%); min-width: unset;">
        <v-icon>add</v-icon>
    </v-btn>
    <v-btn @click="setZoom(-0.2)"
        style="position: absolute; right:5vw; bottom: 5vw; border-radius: 0px 0px 100px 100px; height: 50px; width:100px; transform: translate(+50%, 50%); min-width: unset;">
        <v-icon>remove</v-icon>
    </v-btn>
    <v-tooltip bottom>
        <template v-slot:activator="{ on, attrs }">
            <v-btn icon color="primary" v-bind="attrs" v-on="on" @click="backToFocusedNode()"
                style="position: absolute; right:calc(5vw - 50px); bottom: calc(5vw + 50px); transform: translate(+50%, -50%);">
                <v-icon>loupe</v-icon>
            </v-btn>
        </template>
        back to selected
    </v-tooltip>
    <v-tooltip bottom>
        <template v-slot:activator="{ on, attrs }">
            <v-btn icon color="primary" v-bind="attrs" v-on="on" @click="focus('')"
                style="position: absolute; right:calc(5vw - 50px); bottom: calc(5vw - 50px); transform: translate(+50%, 50%);">
                <v-icon>zoom_out_map</v-icon>
            </v-btn>
        </template>
        show all
    </v-tooltip>
    <span
        style="position: absolute; right:5vw; bottom: 5vw; transform: translate(+50%, -50%); pointer-events: none;">${zoom.toFixed(1)}</span>
</v-card>
{% endblock %}
{% block VueComponentScript %}
{{ layout.cytoscapeCDN() }}
<script>
    cy = cytoscape({
        style: [{
            selector: 'node',
            style: {
                'label': 'data(tag)'
            }
        }, {
            selector: 'node.trunk',
            style: {
                'shape': 'star'
            }
        }, {
            selector: 'node.isExposed',
            style: {
                'background-color': 'green'
            }
        }, {
            selector: 'node.isActive',
            style: {
                'background-color': 'red'
            }
        }, {
            selector: 'node.workspace',
            style: {
                'shape': 'diamond'
            }
        }, {
            selector: 'node.workspace',
            style: {
                'shape': 'triangle'
            }
        },
        {
            selector: 'edge',
            style: {
                'curve-style': 'bezier'
            }
        },
        {
            selector: 'edge[tag*="PULL"]',
            style: {
                'line-style': 'dashed'
            }
        },
        {
            selector: 'edge[tag="WORK_ON"]',
            style: {
                'line-style': 'dotted'
            }
        },
        {
            selector: 'node.uselectable',
            style: {
                'opacity': 0.25
            }
        }, {
            selector: 'node.branch',
            style: {
                'shape': 'rectangle'
            }
        }, {
            selector: 'node.canPull',
            style: {
                'shape': 'diamond'
            }
        },
        ],
        userZoomingEnabled: false,
        userPanningEnabled: false,
        boxSelectionEnabled: false
    })

    function nodeFactory(node, classes) {
        if (node.isActive) {
            classes.push('isActive')
        }
        if (node.canPatch) {
            classes.push('canPatch')
        }
        if (node.property.canPull) {
            classes.push('canPull')
        }
        if (node.isExposed) {
            classes.push('isExposed')
        }
        if (node.isOwner) {
            classes.push('isOwner')
        }
        let output = {
            group: 'nodes',
            data: {
                id: 'node' + node.id,
                tag: node.property.tag,
                deltaGraphId: node.property.deltaGraphId,
                creationDate: new Date(node.property.creationDate)
            },
            classes: classes,
            position: {
                x: 0,
                y: 0
            },
            grabbable: false,
            pannable: false,
            position: {
                x: 0,
                y: 0
            }
        }
        return output
    }

    function edgeFactory(edge) {
        let output = {
            group: 'edges',
            data: {
                id: 'edge' + edge.id,
                source: 'node' + edge.start,
                target: 'node' + edge.end,
                tag: edge.type
            }
        }
        return output

    }
    Vue.component('app-content', {
        data: () => ({
            _focusedNode: null,
            zoom: 0,
            lastFocusedId: null,
            url: "",
            showMenu: false,
            cursor_x: undefined,
            cursor_y: undefined,
            showSelectBar: false,
            snackbarMethod: '',
            _selectedNode: undefined, // this makes the vuetify not observing the object
            selectedNodeClasses: [],
            //{% if request.blueprint == "instructor" %}
            workspaceCreateDialog: false,
            tag: '',
            tagRules: [v => !!v || 'Tag name is required',
            v => (v && v.length > 3 && v.length < 101) ||
                'Tag name should be anything between 4 and 100 charactors',
            v => (v && /{{regExpRules["tag"]}}/.test(v)) ||
                'Tag name can only contains alphanumeric characters, hyphen, comma, colon, dot and space.'
            ],
            //{% endif %}
        }),
        methods: {
            loadData() {
                this.$root.progress.show = true
                fetch(
                    "{{ url_for('RESTful.tree.get', courseCode = courseCode, isInstructor = request.blueprint == 'instructor', isDLTC = request.blueprint == 'DLTC') }}", {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                    .then(response => {
                        try {
                            return response.json()
                        } catch {
                            this.$root.progress.show = false
                            this.$root.errorDisplay({},
                                'Unexpected error occured.')
                        }
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.edges && body.trunk_nodes && body.branch_nodes && body.workspace_nodes) {
                            cy.remove(cy.elements())
                            body.trunk_nodes.forEach(node => {
                                cyNode = cy.add(nodeFactory(node, ["trunk"]))
                                if (node.isActive) {
                                    this._focusedNode = cyNode
                                }
                            })
                            body.branch_nodes.forEach(node => {
                                cy.add(nodeFactory(node, ["branch"]))
                            })
                            body.workspace_nodes.forEach(node => {
                                cy.add(nodeFactory(node, ["workspace"]))
                            })
                            body.edges.forEach(edge => {
                                [edge.start, edge.end].forEach(id => {
                                    let node = cy.getElementById('node' + id)
                                    if (node.length == 0) {
                                        cy.add(nodeFactory({
                                            property: {
                                                tag: 'hidden'
                                            },
                                            id: id
                                        }, ["invisible"]))
                                    }
                                })

                                cy.add(edgeFactory(edge))
                            })
                            let root = cy.nodes('[tag = "init"]')
                            let stepX = 200
                            let stepY = 200

                            function locatePredecessorsX(node) {
                                let thickness = 0
                                let position = node.position()
                                let forkEdges = node.incomers('edge[tag="FORK"]').sort((edgeA, edgeB) => {
                                    let childA = edgeA.source()
                                    let childB = edgeB.source()
                                    return childA.data('creationDate') - childB.data('creationDate')
                                })
                                let patchEdges = node.incomers('edge[tag="PATCH"]').sort((edgeA,
                                    edgeB) => {
                                    let childA = edgeA.source()
                                    let childB = edgeB.source()
                                    return childA.data('creationDate') - childB.data('creationDate')
                                })
                                patchEdges.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        x: position.x,
                                    })
                                    thickness = Math.max(thickness, locatePredecessorsX(child))
                                })
                                forkEdges.forEach(edge => {
                                    thickness++
                                    let child = edge.source()
                                    child.position({
                                        x: position.x + stepX * thickness,
                                    })
                                    thickness += locatePredecessorsX(child)
                                })
                                return thickness
                            }

                            function locatePredecessorsY(node) {
                                let position = node.position()
                                let fixedEdges = node.incomers('edge[tag="PATCH"],edge[tag = "FORK"]')
                                // .filter(edge => {
                                //     let child = edge.source()
                                //     return child.outgoers(
                                //         'edge[tag = "BRANCH_PULL"],edge[tag = "TRUNK_PULL"]'
                                //     ).length == 0
                                // });
                                let pulledEdge = node.incomers(
                                    'edge[tag="BRANCH_PULL"],edge[tag = "TRUNK_PULL"]')
                                fixedEdges.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        y: Math.max(position.y + stepY, child.position().y),
                                    })
                                    let pulling = child.incomers(
                                        'edge[tag = "BRANCH_PULL"],edge[tag = "TRUNK_PULL"]'
                                    )
                                    if (pulling.length > 0) {
                                        pulling.map(edge => edge.source()).forEach(puller => {
                                            puller.position({
                                                y: child.position().y + stepY,
                                            })
                                            locatePredecessorsY(puller)
                                        }

                                        )
                                    }
                                })
                                pulledEdge.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        y: Math.max(position.y + stepY, child.position().y),
                                    })
                                    locatePredecessorsY(child)
                                })
                                fixedEdges.forEach(edge => {
                                    let child = edge.source()
                                    locatePredecessorsY(child)
                                })
                            }

                            function locateWorkspace(node) {
                                let j = Math.PI * 0.75
                                let position = node.position()
                                let workEdges = node.incomers('edge[tag="WORK_ON"]').sort((edgeA,
                                    edgeB) => {
                                    let childA = edgeA.source()
                                    let childB = edgeB.source()
                                    return childA.data('creationDate') - childB.data('creationDate')
                                })
                                workEdges.forEach(edge => {
                                    let child = edge.source()
                                    child.position({
                                        x: position.x + 75 * Math.cos(j),
                                        y: position.y + 75 * Math.sin(j)
                                    })
                                    j = j + Math.PI / 4;
                                })
                                node.incomers('edge[tag!="WORK_ON"]').forEach(edge => {
                                    let child = edge.source()
                                    locateWorkspace(child)
                                })
                            }
                            locatePredecessorsX(root)
                            locatePredecessorsY(root)
                            locateWorkspace(root)
                            this.focus(this._focusedNode.data("id"), 0)
                        } else {
                            this.$root.errorDisplay(body,
                                'Unexpected error on getting versions information.')
                        }
                    })
            },
            // {% if request.blueprint == "instructor" %}
            readyToPush() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                fetch("{{ url_for('RESTful.branch.patch') }}" + this._selectedNode.data("deltaGraphId"), {
                    method: 'PATCH',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        canPull: !this._selectedNode.classes().includes("canPull")
                    })
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        this.$root.responseSnackBar(body,
                            'Creation failed for unknown reason.',
                            () => {
                                this.loadData()
                            })
                    })
            },
            toggleExposure() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                let isExposed = this._selectedNode.classes().includes("isExposed") ? false : true
                fetch("{{ url_for('RESTful.branch.patch') }}" + this._selectedNode.data("deltaGraphId"), {
                    method: 'PATCH',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        isExposed: isExposed,
                    })
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        this.$root.responseSnackBar(body,
                            'Creation failed for unknown reason.',
                            () => {
                                this.loadData()
                            })
                    })

            },
            mergeWithAnother() {
                this.snackbarMethod = 'branch'
                this.selectableNodes = cy.nodes(
                    '.branch[deltaGraphId  != "' + this._selectedNode.data("deltaGraphId") + '"],' +
                    '.trunk')
                this.selectAnotherMode()
            },
            checkout() {
                this.snackbarMethod = 'workspace'
                this.selectableNodes = cy.nodes('.branch,.trunk')
                this.selectAnotherMode()
            },
            createWorkspaceDialogue() {
                this.workspaceCreateDialog = true
            },
            createWorkspace() {
                if (this.$refs.createWorkspaceControl.validate()) {
                    if (this.$root.progress.show == true) {
                        this.$root.bePatientSnackBar.show = true
                        return
                    }
                    this.$root.progress.show = true
                    fetch("{{ url_for('RESTful.workspace.post') }}" + this._selectedNode.data("deltaGraphId"), {
                        method: 'POST',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            tag: this.tag,
                        })
                    })
                        .then(response => {
                            return response.json()
                        })
                        .then(body => {
                            this.$root.progress.show = false
                            this.$root.responseSnackBar(body,
                                'Creation failed for unknown reason.',
                                () => {
                                    this.workspaceCreateDialog = false
                                    this.$refs.createWorkspaceControl.reset()
                                    this.loadData()
                                })
                        })
                }
            },
            commit() {
                this.newTab("{{ url_for('instructor.commit')}}" + this._selectedNode.data("deltaGraphId"))
            },
            // {% endif %}
            // {% if request.blueprint == "DLTC" %}
            setActive() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                fetch("{{ url_for('RESTful.trunk.patch') }}" + this._selectedNode.data("deltaGraphId"), {
                    method: 'PATCH',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        active: true,
                    })
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        this.$root.responseSnackBar(body,
                            'Creation failed for unknown reason.',
                            () => {
                                this.loadData()
                            })
                    })
            },
            release() {
                this.snackbarMethod = 'trunk'
                this.selectableNodes = cy.nodes(
                    '.branch.canPull')
                this.selectAnotherMode()
            },
            // {% endif %}
            selectAnotherMode() {
                cy.nodes().difference(this.selectableNodes).addClass('uselectable')
                cy.nodes().unselectify()
                this.showSelectBar = true
            },
            resume() {
                this.showSelectBar = false
                cy.nodes(".uselectable").removeClass('uselectable')
                cy.nodes().unselectify()
            },
            newTab(url) {
                let w = window.open(url, '_blank')
                w.onbeforeunload = () => {
                    this.loadData()
                }
                w.focus()
                this.resume()
            },
            openFrame(url) {
                this.url = url
                this.resume()
            },
            focus(id, duration = 1000) {
                cy.stop()
                cy.clearQueue()
                this.lastFocusedId = id
                let ele = document.getElementById('cy');
                if (id) {
                    cy.nodes().unselect()
                    let node = cy.getElementById(id)
                    this._focusedNode = node.length > 0 ? node : cy.nodes('node[tag="' + id + '"]')
                    this._focusedNode.select()
                    animation = cy.animation({
                        fit: {
                            eles: this._focusedNode.boundingBox(),
                            padding: ele.offsetWidth * (0.48 - this.zoom * 0.095)
                        },
                        duration: duration
                    })
                } else {
                    animation = cy.animation({
                        fit: {
                            padding: ele.offsetWidth * (0.05 - this.zoom * 0.01)
                        },
                        duration: duration
                    })
                }

                animation.play()
            },
            setZoom(value) {
                this.zoom = this.zoom + value
                this.zoom = Math.min(this.zoom, 1)
                this.zoom = Math.max(this.zoom, 0)
                this.focus(this.lastFocusedId, 200)
            },
            backToFocusedNode() {
                if (this._focusedNode) this.focus(this._focusedNode.data("id"), 500)
            },
        },
        mounted: function () {
            cy.mount(document.getElementById("cy"))
            window.onresize = () => {
                cy.fit()
            }
            self = this
            cy.on('cxttapend', 'node', (event) => {
                console.log(event)
                if (event.target == event.cy) return
                self.showMenu = true
                self.cursor_x = event.originalEvent.clientX
                self.cursor_y = event.originalEvent.clientY
                this._selectedNode = event.target[0]
                this.selectedNodeClasses = event.target[0].classes()
                cy.nodes().unselect()
                cy.edges().unselect()
                event.target[0].select()
            })
            cy.on('tap', 'node', (event) => {
                console.log(event)
                if (event.target == event.cy) return
                if (this.showSelectBar) {
                    // {% if request.blueprint == "instructor" %}
                    if (this.snackbarMethod == 'branch') {
                        if (this.selectableNodes.contains(event.target[0])) {
                            this.newTab("{{ url_for('instructor.branch')}}" + event.target[0].data(
                                'deltaGraphId') + '/' + this
                                    ._selectedNode.data("deltaGraphId"))
                        }
                    }
                    if (this.snackbarMethod == 'workspace') {
                        if (this.selectableNodes.contains(event.target[0])) {
                            fetch("{{ url_for('RESTful.workspace.patch') }}" + this
                                ._selectedNode.data("deltaGraphId"), {
                                method: 'PATCH',
                                cache: 'no-store',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    checkout: true,
                                    deltaGraphId: event.target[0].data(
                                        'deltaGraphId')
                                })
                            })
                                .then(response => {
                                    try {
                                        return response.json()
                                    } catch {
                                        this.$root.progress.show = false
                                        this.$root.errorDisplay({},
                                            'Unexpected error occured.')
                                    }
                                })
                                .then(body => {
                                    this.$root.progress.show = false
                                    this.$root.responseSnackBar(body,
                                        'Sync failed for unknown reason.',
                                        () => {
                                            this.loadData()
                                        })
                                })
                        }
                    }
                    // {% endif %}
                    // {% if request.blueprint == "DLTC" %}
                    if (this.snackbarMethod == 'trunk') {
                        if (this.selectableNodes.contains(event.target[0])) {
                            this.newTab("{{ url_for('DLTC.trunk')}}" + event.target[0].data(
                                'deltaGraphId') + '/' + this
                                    ._selectedNode.data("deltaGraphId"))
                        }
                    }
                    // {% endif %}
                    return
                }
                if (event.target.classes().includes("trunk")) {
                    this.openFrame("{{ url_for('collegue.graphView')}}" + event.target[0].data(
                        'deltaGraphId'))
                }
                if (event.target.classes().includes("branch")) {
                    this.openFrame("{{ url_for('collegue.graphView')}}" + event.target[0].data(
                        'deltaGraphId'))
                }
                if (event.target.classes().includes("workspace")) {
                    this.newTab("{{ url_for('instructor.workspace')}}" + event.target.data(
                        "deltaGraphId"))
                }
                // {% if request.blueprint == "instructor" %}
                // {% endif %}
                // {% if request.blueprint == "DLTC" %}
                // {% endif %}
            })
            cy.on('tap', 'edge', (event) => {
                let tag = event.target[0].data("tag")
                if (tag == "FORK" || tag == "PATCH") {
                    this.openFrame("{{ url_for('collegue.compare')}}" + event.target[0].source().data(
                        'deltaGraphId') + "/" + event.target[0].target().data(
                            'deltaGraphId'))

                }
                else if (tag.includes("PULL")) {
                    let parentOfSource = event.target[0].source().connectedEdges(
                        '[tag = "FORK"],[tag = "PATCH"]').targets('[id != "' + event.target[
                            0]
                            .data('id') + '"]')
                    if (parentOfSource.length < 1) return;
                    this.openFrame("{{ url_for('collegue.compare')}}" + event.target[0].source().data(
                        'deltaGraphId') + "/" + parentOfSource[0].data(
                            'deltaGraphId'))

                }
            })
            window.addEventListener('keydown', (event) => {
                if (event.key == "ArrowLeft" || event.key == "ArrowRight") {
                    let sibling = this._focusedNode.outgoers('[tag = "FORK"]').
                        targets().incomers('[tag = "FORK"]').sources()
                    let siblingIndex
                    if (sibling.length == 0) {
                        siblingIndex = -1
                        sibling = this._focusedNode.incomers('[tag = "FORK"]').sources()
                        if(sibling.length == 0){
                            return
                        }
                    }
                    else {
                        let i = 0
                        for (node of sibling) {
                            if (node.data("id") == this._focusedNode.data("id")) {
                                siblingIndex = i
                                break
                            }
                            i++
                        }
                    }
                    if (event.key == "ArrowLeft") {
                        siblingIndex--
                    }
                    if (event.key == "ArrowRight") {
                        siblingIndex++
                    }
                    siblingIndex = (
                        (siblingIndex % sibling.length) + sibling.length) % sibling.length
                    this._focusedNode = sibling[siblingIndex]
                    this.focus(this._focusedNode.data("id"))
                }
                if (event.key == "ArrowUp" || event.key == "ArrowDown") {
                    if (event.key == "ArrowUp") {
                        target = this._focusedNode.connectedEdges('[tag = "FORK"],[tag = "PATCH"]').target()
                    }
                    if (event.key == "ArrowDown") {
                        target = this._focusedNode.connectedEdges('[tag = "PATCH"]').source()
                    }
                    if (target) {
                        this._focusedNode = target
                        this.focus(this._focusedNode.data("id"))
                    }
                }
                if (event.key == "Escape") {
                    this.focus('')
                }

            })
            this.$refs.iframe.addEventListener('onCloseWindow', () => {
                this.loadData()
            }, false);

            this.loadData()
        },
        template: '#content',
        delimiters: ['${', '}'],
    })
</script>
{% endblock %}