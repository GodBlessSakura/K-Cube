{% extends "layout.html" %}
{% import 'layout.html' as layout with context %}
{% block VueComponent %}
<div>
    <v-container id="app">
        <v-row>
            <v-col>
                <v-card-title>
                    {{ courseCode }}<br>
                    course plan
                </v-card-title>
            </v-col>
            <v-col>
                <v-card-text>
                    <v-btn v-show="graph && (workspace == null || graph?.deltaGraphId != workspace?.deltaGraphId)" small
                        text :href="'{{url_for('instructor.workspace')}}' + graph?.deltaGraphId">open exposed
                        graph in ${workspace?'another':'the'} editor<v-icon>open_in_new</v-icon>
                    </v-btn>
                    <v-btn v-show="workspace == null && graph == null" small text
                        href="{{ url_for('course', courseCode = courseCode)}}?hideGraph">
                        create/expose a workspace<v-icon>work</v-icon>
                    </v-btn>
                </v-card-text>
            </v-col>
        </v-row>
        <v-row v-if="graph" no-gutters>
            <v-col>
                <v-btn @click="constructTimetable(triples,[],true)">recompute</v-btn>
                <v-btn v-show="preview || unsyncedCount > 0" color="success" @click="submitTable()">submit</v-btn>
                <v-btn v-show="preview" color="error" @click="loadData()">undo</v-btn>
            </v-col>
            <v-col cols="auto">
                <v-form ref="entityForm">
                    <v-text-field :rules="nameRules" label="create entity" dense flat solo v-model="entity_name">
                    </v-text-field>
                </v-form>
            </v-col>
            <v-col cols="auto">
                <v-btn @click="createEntity()">create</v-btn>
            </v-col>
            <v-col cols="auto">
                <draggable v-model="deck" :group="{name:'schedule', put: false}" handle=".handle"
                    style="height: 100%; background: content-box grey">
                    <kcube-schedule-item v-for="child of deck" :node="child" deck>
                    </kcube-schedule-item>
                </draggable>
            </v-col>
        </v-row>
        <v-row>
            <v-col>

            </v-col>
            <v-col cols="auto">
                <kcube-schedule-item ref="root" root v-if="tree" :node="tree"
                    @showDetails="showDetails($event[0],$event[1])" @countNotSync="countNotSync($event)"
                    @exclusiveHeadTriple="exclusiveHeadTriple($event)">
                </kcube-schedule-item>
            </v-col>
            <v-col>

            </v-col>
        </v-row>
    </v-container>
    <v-menu v-model="showMenu" :position-x="x" :position-y="y" absolute offset-y>
        <v-card>
            <v-card-title>
                Entity ID: ${ details?.name }
            </v-card-title>
            <v-card-subtitle>
                description: ${ details?.desc }
            </v-card-subtitle>
            <v-card-actions>
                <v-btn text color="primary" v-if="inIframe" @click="postMessage('open-entity', details, '*')">
                    open entity editor
                </v-btn>
                <v-btn text color="primary" v-show="details?.notSync" @click="$refs.root.sync(details)">
                    sync
                </v-btn>
                <v-btn text color="error" @click="decapitate(details)">
                    delete
                </v-btn>
            </v-card-actions>
        </v-card>
    </v-menu>
    <v-snackbar right top style="z-index:5;" :value="showMenuTips" timeout="-1">
        ${unsyncedCount?'There are '+ unsyncedCount + ' unsynced item'+ (unsyncedCount>1?'s':'') +
        '. You may right-click on them for syncing':
        'You may right-click on item for details'}
    </v-snackbar>
</div>
{% endblock %}

{% block VueComponentScript %}
{% macro kcubeScheduleItem() %}
<v-badge :icon="deck?null:node.syncError?'sync_problem':'sync'" :content="deck?node.numItem:null"
    :value="deck || (node.notSync && !root)" :color="node.syncError?'error':'primary'"
    v-ripple="!root?{ class: 'primary--text' }:null" style="padding: unset; float:left; margin:5px 8px">
    <v-card v-bind:id="'entity:'+node.name" :key="node.name" @dragleave="showAction=false"
        @contextmenu.stop="!root?$emit('showDetails',[$event,node]):null">
        <div>

        </div>
        <v-list-item v-if="!root" v-show="!showAction || deck"
            @dragover="showAction = (dragging || weeks.length>0)?false:true" @mouseenter="hovering = true"
            @mouseleave="hovering = false">
            <v-icon small class="handle" draggable="true" @dragend="dragging=false" @dragstart="dragging=true">
                drag_indicator</v-icon>
            <v-text-field background-color="transparent" dense hide-details flat solo v-model="node.desc"
                @change="node.notSync=true;patchEntity(node, node.week)"></v-text-field>
            <v-list-item-action style="margin: unset" v-show="hovering && !dragging && !deck">
                <v-btn icon x-small @click="climb(-1)" v-show="node.week > 1">
                    <v-icon x-small>arrow_drop_up</v-icon>
                </v-btn>
                <v-btn icon x-small @click="climb(1)" v-show="node.week < weekInSemester">
                    <v-icon x-small>arrow_drop_down</v-icon>
                </v-btn>
            </v-list-item-action>
        </v-list-item>
        <v-list-item v-if="!root && weeks.length== 0 && node.schedule[node.week]?.length == 0"
            v-show="showAction && !deck" @drop="showAction=false">
            <v-row no-gutters>
                <v-col style="align-items: center;display: flex;">
                    <v-icon small>add</v-icon>
                </v-col>
                <v-col>
                    <draggable v-model="node.schedule[node.week]" :key="keys[node.week]"
                        :group="{name:'schedule', put: true}" handle=".handle" @add="add($event, node.week)"
                        @change="render($event); showAction=false"
                        style="height: 100%; background: content-box grey; width: 186px" animation="300"
                        @dragover="showAction = dragging?false:true" swapThreshold="0.6">
                    </draggable>
                </v-col>
                <v-col style="align-items: center;display: flex;">
                    <v-icon small style="color:transparent">add</v-icon>
                </v-col>
            </v-row>
        </v-list-item>
        <div style="padding: 5px;" v-show="weeks.length>0 && !deck">
            <v-row v-for="week in weeks" v-show="(!root || node.schedule[week]?.length > 0) && !dragging" no-gutters>
                <v-col cols="auto">
                    <v-list-item style="padding:unset; width:50px" dense>week ${week}
                        ${root&&spans[week] > week?(' - week ' + spans[week]) :''}
                    </v-list-item>
                </v-col>
                <v-col>
                    <draggable v-model="node.schedule[week]" :key="keys[week]" :group="{name:' schedule', put: true}"
                        handle=".handle" @add="add($event, week)" @change="render($event)"
                        @dragover="showAction = dragging?false:true" style="height: 100%; background: content-box grey"
                        animation="300" swapThreshold="0.2">
                        <kcube-schedule-item ref="children" v-for="child of node.schedule[week]" :node="child"
                            @showDetails="$emit('showDetails',$event)" @countNotSync="$emit('countNotSync',$event)"
                            @exclusiveHeadTriple="$emit('exclusiveHeadTriple',$event)">
                        </kcube-schedule-item>
                    </draggable>
                </v-col>
            </v-row>
        </div>
    </v-card>
</v-badge>
{% endmacro %}
<script type="text/x-template" id="kcube-schedule-item">
    {{ kcubeScheduleItem()}}
</script>
<script>
    function flattenSchedule(schedule) {
        return Object.keys(schedule).reduce((previous, current) => {
            return previous.concat(schedule[current])
        }, [])
    }
    Vue.component('kcube-schedule-item', {
        props: {
            deck: {
                type: Boolean
            },
            node: {
                type: Object,
                required: true
            },
            root: Boolean
        },
        watch: {
            node: function (newVal, oldVal) {
                this.node._vue = this
                this.render()
            },
        },
        data: () => ({
            parentHovered: false,
            showAction: false,
            dragging: false,
            hovering: false,
            weekInSemester: weekInSemester,
            weeks: [],
            spans: {},
            keys: {}
        }),
        methods: {
            add(event, week) {
                let entity = this.node.schedule[week][event.newIndex]
                this.patchEntity(entity, week)
            },
            patchEntity(entity, week) {
                let promises = []
                if (entity.notSync || entity.week != week) {
                    entity.week = week
                    promises.push(fetch(
                        "{{ url_for('RESTful.activity.post', courseCode = courseCode) | safe}}" +
                        encodeURIComponent(
                            entity.name), {
                        method: 'POST',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            desc: entity.desc,
                            week: entity.week
                        })
                    })
                        .then(response => {
                            try {
                                return response.json()
                            } catch {
                                this.$root.progress.show = false
                                this.$root.errorDisplay({},
                                    'Unexpected error occured.')
                            }
                        })
                        .then(body => {
                            this.$root.progress.show = false
                            if (body.activity) {
                                try {
                                    if (window.self !== window.top) {
                                        throw ''
                                    }
                                } catch (e) {
                                    let { _vue, parent, children, schedule, ...orphan } = entity
                                    window.parent.postMessage({
                                        message: 'update-entity',
                                        payload: orphan
                                    }, '*')
                                }
                            } else {
                                this.$root.errorDisplay(body,
                                    'Unexpected error on setting courses plan information.')
                                throw ''
                            }
                        }))
                }
                console.log(entity)
                if (entity.parent === undefined || (entity.parent && this.node.name != entity.parent.name && this.node.name != entity.name)) {
                    if (workspaceDeltagraphId)
                        promises.push(fetch("{{ url_for('RESTful.triple.put') }}" + workspaceDeltagraphId, {
                            method: 'PUT',
                            cache: 'no-store',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                h_name: entity.name,
                                r_name: tree_edge_name,
                                t_name: this.node.name,
                                r_value: true,
                                exclusive_head: true,
                            })
                        })
                            .then(response => {
                                try {
                                    return response.json()
                                } catch {
                                    this.$root.progress.show = false
                                    this.$root.errorDisplay({},
                                        'Unexpected error occured.')
                                }
                            })
                            .then(body => {
                                if (body.triple) {
                                    entity.parent = this.node
                                    this.$emit('exclusiveHeadTriple', body.triple)
                                    window.parent.postMessage({
                                        message: 'coursePlan-exclusiveHeadTriple',
                                        payload: body.triple
                                    }, '*')
                                } else {
                                    this.$root.errorDisplay(body,
                                        'Unexpected error when deleted triple.')
                                    throw ''
                                }
                            }))
                }
                if (promises.length > 0) { entity.notSync = true }
                Promise.all(promises).then(data => {
                    entity.notSync = false
                    this.$emit('countNotSync', { scroll: false })
                    this.$emit('countNotSync', { scroll: false })
                }).catch((reason) => {
                    entity.syncError = true
                    this.$emit('countNotSync', { scroll: true })
                }).finally(() => {
                    entity._vue.$forceUpdate()
                })
            },
            render(event = null) {
                if (this.node.schedule) {
                    this.weeks = []
                    this.spans = {}
                    let week = Object.keys(this.node.schedule).filter(week => this.node.schedule[week].length > 0).map(week => Number(week))
                    if (week.length > 0) {
                        let max = Math.max(...week)
                        let min = Math.min(...week)
                        this.weeks = [...Array(max - min + 1).keys()].map(week => week + min)
                    }
                    this.keys = {}
                    for (const week of this.weeks) {
                        function flatten(nodes) {
                            return [...nodes, ...nodes.flatMap(n => {
                                let children = flattenSchedule(n.schedule)
                                return [...children, ...children.length > 0 ? flatten(children) : []]
                            })]
                        }
                        this.keys[week] = week + ';'
                        if (this.node.schedule[week] && this.node.schedule[week].length > 0) {
                            this.keys[week] += this.node.schedule[week].map(node => node.name).join(';')
                            this.spans[week] = Math.max(...flatten(this.node.schedule[week]).map(n => n.week).filter(w => Number.isInteger(w)))
                        }
                        else {
                            if (!(week in this.node.schedule)) this.node.schedule[week] = []
                        }
                    }
                    if (!(this.node.week in this.node.schedule)) this.node.schedule[this.node.week] = []
                }
            },
            climb(offset) {
                console.log(this.node.parent)
                let newWeek = this.node.week + offset
                if (newWeek > 0 && newWeek <= weekInSemester) {
                    let { _vue, parent, children, schedule, ...orphan } = this.node
                    orphan.week = newWeek
                    this.node.parent._vue.updateActivity(orphan, this.node.week)
                    this.node.parent._vue.patchEntity(this.node, newWeek)
                }
            },
            updateActivity(activity, oldWeek = null) {
                let foundChild = flattenSchedule(this.node.schedule).find(child => child.name == activity.name)
                if (foundChild) {
                    let isOldWeekNull = oldWeek == null
                    if (isOldWeekNull) {
                        oldWeek = foundChild.week
                    }
                    let index = this.node.schedule[oldWeek].findIndex(sibling => sibling.name == foundChild.name)
                    let newWeek = Number(activity.week)
                    this.node.schedule[oldWeek].splice(index, 1)
                    if (!(newWeek in this.node.schedule)) this.node.schedule[newWeek] = []
                    this.node.schedule[newWeek].push(foundChild)
                    if (isOldWeekNull) {
                        foundChild.desc = activity.desc
                        foundChild.week = newWeek
                    }
                    console.log(oldWeek)
                    console.log(this.node.schedule)
                    this.render()
                    setTimeout(() => {
                        let el = this.$refs.children.find(child => child.node.name == activity.name).$el
                        el.scrollIntoView({
                            behavior: "smooth",
                            block: "center"
                        })
                        let ev = new Event("mousedown")
                        let offset = el.getBoundingClientRect()
                        ev.clientX = offset.left + 1
                        ev.clientY = offset.top + 1
                        el.dispatchEvent(ev)
                        this.$nextTick(function () {
                            el.dispatchEvent(new Event("mouseup"))
                        })
                    }, 500)
                }
                else {
                    if (this.$refs.children)
                        this.$refs.children.forEach(child => child.updateActivity(activity))
                }
            },
            sync(target = null) {
                if (target != null) {
                    if (target.name == this.node.name) {
                        this.sync()
                    }
                    else {
                        if (this.$refs.children)
                            this.$refs.children.forEach(child => child.sync(target))
                    }
                }
                else {
                    if (this.node.notSync) {
                        this.patchEntity(this.node, this.node.week)
                    }
                }
            },
            test(s = "test") {
                console.log(s)
            }
        },
        mounted: function () {
            this.node._vue = this
            this.render()
        },
        template: '#kcube-schedule-item',
        delimiters: ['${', '}'],
    })
</script>
<style>
    .v-text-field input,
    .v-list-item {
        font-size: small;
    }

    .v-list-item {
        padding: 0 0 0 8px;
    }

    #sortable>div {
        float: left;
    }
</style>
<script>
    function traversal(name, triples, activities) {
        let activity = activities.filter(a => a.name == name)
        let node = {
            name: name,
            desc: activity.length > 0 ? activity[0].desc : name,
            week: activity.length > 0 ?
                (Number.isInteger(Number(activity[0].week)) ? Number(activity[0].week) : null) : null,
            children: []
        }
        triples = triples.filter(triple => {
            if (triple.t_name == name) {
                node.children.push(triple.h_name)
                return false
            }
            return true
        })
        triples = triples.filter(triple => { // do for remove mutli path
            if (node.children.includes(triple.h_name)) {
                return false
            }
            return true
        })
        node.children = node.children.map(child => traversal(child, triples, activities))
        return node
    }
    function sortChildren(node) {
        if (node.children.length == 0) {
            node.numItem = 1
        }
        else {
            node.children.forEach(child => (sortChildren(child)))
            node.children = node.children.sort((childA, childB) => {
                if (childA.week != null && childB.week != null) { return childA.week - childB.week }
                else if (childA.week != null & childB.week == null) { return -1 }
                else if (childA.week == null & childB.week != null) { return 1 }
                else { return childB.numItem - childA.numItem }
            })
            node.children.forEach(child => child.parent = node)
            node.numItem = node.children.map(child => child.numItem).reduce((previous, current) => previous + current)
        }
    }
    function allocate(node, slot, totalItem) {
        node.notSync = false
        if (node.week === null) {
            node.notSync = true
            node.week = Math.min(Math.round(slot * weekInSemester) + 1, weekInSemester)
        }
        if (node.children.length == 0) {
            slot = slot + 1 / totalItem
        }
        node.children.forEach(child => {
            slot = allocate(child, slot, totalItem)
        })
        node.schedule = node.children.reduce(
            (previous, child) => {
                if (previous[child.week]) {
                    previous[child.week].push(child)
                }
                else {
                    previous[child.week] = [child]
                }
                return previous
            }, Object.create(null))
        delete node.children
        return slot
    }
    let tree_edge_name = "Subtopic in"
    let workspaceDeltagraphId
    let weekInSemester = 13
    Vue.component('app-content', {
        data: () => ({
            tree: null,
            x: null,
            y: null,
            showMenuTips: false,
            showMenuTipsInterval: null,
            unsyncedCount: 0,
            details: null,
            showMenu: false,
            inIframe: false,
            preview: false,
            graph: null,
            workspace: null,
            activityWeekRules: [v => !!v || 'week is required',
            v => (v && v > 0 && v < 14) ||
                'Week should be between 1 and 13',
            ],
            nameRules: [v => !!v || 'Name is required',
            v => (v && v.length > 1 && v.length) < 99 ||
                'Name should be anything between 2 and 99 charactors',
            v => (v && /{{regExpRules["name"]}}/.test(v)) ||
                'Name can only contains alphanumeric characters and space.'
            ],
            entity_name: '',
            deck: []
        }),

        methods: {
            loadData() {
                this.$root.progress.show = true
                let activityPromise = fetch(
                    "{{ url_for('RESTful.activity.query', ofUser=True, courseCode = courseCode) | safe}}", {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                    .then(response => {
                        try {
                            return response.json()
                        } catch {
                            this.$root.progress.show = false
                            this.$root.errorDisplay({},
                                'Unexpected error occured.')
                        }
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.activities) {
                            return body.activities
                        } else {
                            this.$root.errorDisplay(body,
                                'Unexpected error on getting courses plan information.')
                        }
                    })
                let graphPromise = fetch(
                    "{{ url_for('RESTful.triple.getCourse', courseCode = courseCode, userId = USER.userId) }}", {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                    .then(response => {
                        try {
                            return response.json()
                        } catch {
                            this.$root.progress.show = false
                            this.$root.errorDisplay({},
                                'Unexpected error occured.')
                        }
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.course && body.triples) {
                            this.graph = body.graph
                            console.log(this.graph)
                            workspaceDeltagraphId = this.graph ? this.graph.deltaGraphId : null
                            return body.triples
                        } else {
                            this.$root.errorDisplay(body,
                                'Unexpected error on getting courses information.')
                        }
                    })
                return Promise.all([graphPromise, activityPromise]).then(data => {
                    tripleFilter = triple => triple.r_name == tree_edge_name && triple.r_value == true
                    let triples = data[0] ? data[0].filter(tripleFilter) : []
                    let activities = data[1]
                    this.triples = triples
                    this.activities = activities
                    this.constructTimetable(triples, activities)
                    this.countNotSync()
                })
            },
            constructTimetable(triples, activities, preview = false) {
                this.preview = preview
                triples = [...triples]
                this.tree = traversal("{{courseCode}}", triples, activities)
                sortChildren(this.tree)
                allocate(this.tree, 0, this.tree.numItem)
                console.log(this.tree)
                if (!preview)
                    this.$nextTick(() => { this.submitTable() })
            },
            submitTable() {
                this.preview = false
                function recursiveSubmit(node) {
                    if (node.notSync) {
                        node._vue.sync()
                    }
                    flattenSchedule(node.schedule).filter(node => node.notSync).forEach(child => recursiveSubmit(child))
                }
                recursiveSubmit(this.tree)
            },
            showDetails(event, entity) {
                event.preventDefault()
                this.x = event.clientX
                this.y = event.clientY
                let { _vue, parent, children, schedule, ...orphan } = entity
                this.details = orphan
                delete this.details._vue
                this.$nextTick(() => {
                    this.showMenu = true
                })
                this.showMenuTips = this.unsyncedCount ? true : false
                this.wheelInterval ? clearInterval(this.wheelInterval) : null
                this.wheelInterval = setInterval(() => { this.showMenuTips = true }, 10000)

            },
            postMessage(message, payload, domain) {
                window.parent.postMessage({
                    message: message,
                    payload: payload
                }, domain)

            },
            countNotSync(option = {}) {
                let firstNotSync
                function countNotSync(previous, node) {
                    let children = flattenSchedule(node.schedule)
                    let count = previous + (node.notSync ? 1 : 0)
                    if (node.notSync && firstNotSync == undefined) {
                        firstNotSync = node
                    }
                    if (children.length > 0) {
                        count += children.reduce(countNotSync, 0)
                    }
                    return count
                }
                this.unsyncedCount = flattenSchedule(this.tree.schedule).reduce(countNotSync, 0)
                if (this.unsyncedCount > 0) {
                    this.showMenuTips = true
                }
                if (firstNotSync && option.scroll) {
                    let el = firstNotSync._vue.$el
                    el.scrollIntoView({
                        behavior: "smooth",
                        block: "center"
                    })
                    let ev = new Event("mousedown")
                    let offset = el.getBoundingClientRect()
                    ev.clientX = offset.left + 1
                    ev.clientY = offset.top + 1
                    el.dispatchEvent(ev)
                    this.$nextTick(function () {
                        el.dispatchEvent(new Event("mouseup"))
                    })
                }
            },
            exclusiveHeadTriple(payload) {
                this.triples = this.triples.filter(triple => {
                    return triple.h_name != payload.h_name
                })
                this.triples.push(payload)
            },
            decapitate(entity) {
                fetch("{{ url_for('RESTful.triple.post') }}" + workspaceDeltagraphId, {
                    method: 'POST',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        h_name: entity.name,
                        r_name: tree_edge_name,
                        decapitate: true,
                    })
                })
                    .then(response => {
                        try {
                            return response.json()
                        } catch {
                            this.$root.progress.show = false
                            this.$root.errorDisplay({},
                                'Unexpected error occured.')
                        }
                    })
                    .then(body => {
                        if (body.triples) {
                            this.triples = this.triples.filter(triple => {
                                return body.triples.filter(removed => triple.h_name == removed.h_name &&
                                    triple.r_name == removed.r_name &&
                                    triple.t_name == removed.t_name).length == 0
                            })
                            this.constructTimetable(this.triples, this.activities)
                            window.parent.postMessage({
                                message: 'coursePlan-decapitate',
                                payload: body.triples
                            }, '*')
                        } else {
                            this.$root.errorDisplay(body,
                                'Unexpected error when deleted triple.')
                            throw ''
                        }
                    })
            },
            createEntity() {
                if (this.$refs.entityForm.validate()) {
                    let entity = traversal(this.entity_name, [...this.triples], this.activities)
                    sortChildren(entity)
                    allocate(entity, 0, entity)
                    entity.notSync = false
                    this.deck = [entity
                        // {
                        //     name: this.entity_name,
                        //     desc: this.entity_name,
                        //     notSync: false,
                        //     numItem: 1,
                        //     parent: { name: null },
                        //     schedule: [],
                        //     week: -1,
                        // }
                    ]
                }
            }
        },
        mounted: function () {
            window.addEventListener('beforeunload', (e) => {
                this.countNotSync()
                if (this.unsyncedCount > 0) {
                    e.preventDefault()
                    e.returnValue = this.unsyncedCount + 'changes are still uploading';
                }
            });
            try {
                if (window.self !== window.top) {
                    throw ''
                }
            } catch (e) {
                this.inIframe = true
                window.parent.addEventListener('beforeunload', (e) => {
                    this.countNotSync()
                    if (this.unsyncedCount > 0) {
                        e.preventDefault()
                        e.returnValue = this.unsyncedCount + 'changes are still uploading';
                    }
                });
            }
            let loadDataPromise = this.loadData()
            window.onmessage = (e) => {
                if (e.data) {
                    const {
                        message,
                        payload
                    } = e.data

                    if (message == "graphEditor-activity") {
                        this.$refs.root.updateActivity(payload)
                    } else if (message == "graphEditor-workspace") {
                        this.workspace = payload

                    } else if (message == "graphEditor-exposureToggle") {
                        this.loadData()

                    } else if (message == "graphEditor-createTriple") {
                        this.triples.push(payload)
                        this.constructTimetable(this.triples, this.activities)

                    } else if (message == "graphEditor-deleteTriple") {
                        this.triples = this.triples.filter(triple => {
                            return triple.h_name != payload.h_name ||
                                triple.r_name != payload.r_name ||
                                triple.t_name != payload.t_name
                        })
                        this.constructTimetable(this.triples, this.activities)
                    }
                }
            }
            window.parent.postMessage({
                message: 'coursePlan-mount'
            }, '*')
            this.$root.$on('post-activities', function (activities) {

            })
            this.wheelInterval = setInterval(() => { this.showMenuTips = true }, 10000)
        },
        template: '#content',
        delimiters: ['${', '}'],
    })

    function updateItem(item) {
        app.$emit('post-activity', item)
    }
</script>
{% endblock %}