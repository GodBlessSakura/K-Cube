{% extends "layout.html" %}
{% import 'layout.html' as layout %}
{% block VueComponent %}
<v-card style="height: 100%; width: 100%;">
    <v-switch readonly inset :loading="publishLoading" v-model="publishSwitch"
        :label="publishSwitch?'published':'unpublished'" @click="toggleStatus">
    </v-switch>
    <div style="height: 75vh; width: 90vw;">
        <div id="editor" style="height: 100%; width: 100%;"></div>
        <v-fab-transition>
            <v-btn color="primary" absolute bottom right fab @click="networkFit()">
                <v-icon>fit_screen</v-icon>
            </v-btn>
        </v-fab-transition>
        <v-fab-transition>
            <v-btn color="primary" absolute top right fab @click="removeUnreachable">
                <v-icon>cleaning_services</v-icon>
            </v-btn>
        </v-fab-transition>
    </div>
    <v-bottom-sheet v-model="tripleBottomSheet" inset persistent :hide-overlay="true" no-click-animation>
        <v-sheet>
            <v-form ref="tripleForm">
                <v-container>
                    <v-row>
                        <v-btn :ripple="false" color="error" plain block small @click="unselectAll" elevation="2">
                            dismiss
                            <v-icon right>
                                clear_all
                            </v-icon>
                        </v-btn>
                    </v-row>
                    <v-row>
                        <v-col>
                            <v-combobox v-model="h_name" :items="concepts" :rules="nameRules" label="head entity"
                                @focus="nodeFieldFocus('head')" @input="nodeFieldChange"></v-combobox>
                        </v-col>
                        <v-col>
                            <v-select v-model="r_name" :rules="nameRules" :items="relationships" label="relationship"
                                @input="edgeFieldChange">
                            </v-select>
                        </v-col>
                        <v-col>
                            <v-combobox v-model="t_name" :items="concepts" :rules="nameRules" label="tail entity"
                                @focus="nodeFieldFocus('tail')" @input="nodeFieldChange"></v-combobox>
                        </v-col>
                    </v-row>
                    <v-row>
                        <v-btn @click="createTriple" v-if="!isSelectingEdge">
                            Create link
                        </v-btn>
                        <v-btn color="error" @click="deleteTriple" v-else>
                            delete link
                        </v-btn>
                    </v-row>
                </v-container>
            </v-form>
        </v-sheet>
    </v-bottom-sheet>
</v-card>
{% endblock %}
{% block VueComponentScript %}
{{ layout.visCDN() }}
<script>
    /*https://github.com/almende/vis/issues/2567
    getter and setter proxy of vue will mess up the vis
    */
    nodes = new vis.DataSet([]);
    edges = new vis.DataSet([]);
    network = undefined
    function edgeIdFromNames(h_name, r_name, t_name) {
        return h_name + '.' + r_name + '.' + t_name
    }
    function nodeColorFactory({ isTempory = undefined, isRoot = undefined, isNew = undefined }) {
        let color = {
            border: isTempory ? '#ff8787' : isNew ? '#47f5be' : '#87a3ff',
            background: isTempory ? '#ffbfbf' : isNew ? '#bfffeb' : '#b6c9fc',
            highlight: {
                border: isTempory ? '#ff4d4d' : '#bf87ff',
                background: isTempory ? '#ff8787' : '#d7b6fc',
            }
        }
        return color
    }
    function edgeColorFactory({ isTempory = undefined, isNew = undefined }) {
        let nodeColor = nodeColorFactory({ isTempory: isTempory, isNew: isNew })
        let color = {
            color: nodeColor.border,
            highlight: nodeColor.highlight.border
        }
        return color
    }
    function nodeFactory({ name, imageURL, title = undefined, isTempory = undefined, isRoot = undefined, isNew = undefined }) {
        let node = {
            shape: imageURL ? 'circularImage' : 'dot',
            size: 30,
            id: name, label: name,
            image: imageURL ? imageURL : undefined,
            color: nodeColorFactory({ isTempory: isTempory, isRoot: isRoot, isNew: isNew }),
            fixed: isRoot ? true : undefined,
            title: title,
        }
        return node
    }
    function edgeFactory({ from, to, label, title = undefined, isTempory = undefined, isNew = undefined }) {
        let edge = {
            font: {
                size: 12,
                align: 'horizontal',
                vadjust: 0
            },
            length: 250,
            arrows: {
                to: true
            },
            smooth: false,
            from: from, to: to, label: label,
            id: edgeIdFromNames(from, label, to),
            dashed: isTempory ? 'dashed' : undefined,
            color: edgeColorFactory({ isTempory: isTempory, isNew: isNew }),
            title: title,
        }
        return edge

    }
    Vue.component('app-content', {
        data: () => ({
            relationships: [],
            nameRules: [v => !!v || 'Name is required',
            v => v.length > 3 && v.length < 101 || 'Name should be anything between 4 and 100 charactors',
            v => /^[a-zA-Z0-9\s]+$/.test(v) || 'Name can only contains alphanumeric characters and space.'
            ],
            h_name: '',
            t_name: '',
            r_name: '',
            tripleBottomSheet: false,
            isSelectingEdge: false,
            focusing: '',
            wasNewNode: [],
            wasNewEdge: [],
            publishLoading: true,
            publishSwitch: null,
            concepts: []
        }),
        methods: {
            loadData() {
                this.$root.progress.show = true
                fetch("{{ url_for('RESTful.draft') }}" + 'render/' + '{{ draftId }}', {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.draft && body.triples) {
                            this.publishLoading = false
                            this.publishSwitch = body.draft.status == "published"
                            let nodeSet = new Set()
                            nodeSet.add(body.draft.root)
                            body.triples.forEach(triple => {
                                edges.add(
                                    edgeFactory({
                                        from: triple.h_name,
                                        to: triple.t_name,
                                        label: triple.r_name
                                    }
                                    )
                                )
                                nodeSet.add(triple.h_name)
                                nodeSet.add(triple.t_name)
                            });
                            nodeSet.forEach(node => {
                                nodes.add(nodeFactory({ name: node }))
                            })
                            nodes.update(nodeFactory({
                                name: body.draft.root,
                                imageURL: body.draft.course.imageURL,
                                isRoot: true
                            }))
                            let data = {
                                nodes: nodes,
                                edges: edges,
                            };
                            let container = document.getElementById("editor");
                            let options = {
                                interaction: {
                                    selectConnectedEdges: false,
                                },
                                physics: {
                                    repulsion: {
                                        springLength: 800
                                    }
                                }
                            };
                            network = new vis.Network(container, data, options);
                            self = this
                            network.on('selectNode', (event) => {
                                if (self.isSelectingEdge) {
                                    self.clearForm()
                                }
                                if (!self.h_name || this.focusing == "head") {
                                    self.h_name = event.nodes[0]
                                }
                                else {
                                    self.t_name = event.nodes[0]
                                }
                                self.isSelectingEdge = false
                                self.tripleBottomSheet = true;
                            })
                            network.on('selectEdge', (event) => {
                                self.tripleBottomSheet = true;
                                edgeData = edges.get(event.edges[0])
                                self.h_name = edgeData.from
                                self.r_name = edgeData.label
                                self.t_name = edgeData.to
                                self.isSelectingEdge = true
                            })

                        }
                        else {
                            if (body.message) {
                                this.$root.errorSnackBar.message = body.message
                                this.$root.errorSnackBar.show = true
                            }
                            else {
                                this.$root.errorSnackBar.message = 'Unexpected error on getting draft information.'
                                this.$root.errorSnackBar.show = true
                            }
                        }
                    })
                fetch("{{ url_for('RESTful.listApprovedRelationships') }}", {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.relationships) {
                            this.relationships = body.relationships
                        }
                        else {
                            if (body.message) {
                                this.$root.errorSnackBar.message = body.message
                                this.$root.errorSnackBar.show = true
                            }
                            else {
                                this.$root.errorSnackBar.message = 'Unexpected error on getting relationship information.'
                                this.$root.errorSnackBar.show = true
                            }
                        }
                    })
                fetch("{{ url_for('RESTful.listEntity') }}", {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.entities) {
                            this.concepts = body.entities.map(e => e.concept.name)
                        }
                        else {
                            if (body.message) {
                                this.$root.errorSnackBar.message = body.message
                                this.$root.errorSnackBar.show = true
                            }
                            else {
                                this.$root.errorSnackBar.message = 'Unexpected error on getting relationship information.'
                                this.$root.errorSnackBar.show = true
                            }
                        }
                    })
            },
            createTriple() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                if (this.$refs.tripleForm.validate()) {
                    this.$root.progress.show = true
                    fetch("{{ url_for('RESTful.triple') }}" + '{{ draftId }}', {
                        method: 'PUT',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            h_name: this.h_name, r_name: this.r_name,
                            t_name: this.t_name,
                        })
                    })
                        .then(response => {
                            return response.json()
                        })
                        .then(body => {
                            this.$root.progress.show = false
                            if (body.triple) {
                                this.wasNewNode.forEach(nodeId => {
                                    nodes.update({ id: nodeId, color: nodeColorFactory({}) })
                                })
                                this.wasNewEdge.forEach(edgeId => {
                                    edges.update({ id: edgeId, color: edgeColorFactory({}) })
                                })
                                this.unselectAll()
                                let triple = body.triple;
                                [triple.h_name, triple.t_name].forEach(name => {
                                    if (nodes.get({
                                        filter: (element =>
                                            element.id == name
                                        )
                                    }).length < 1) {
                                        nodes.add(nodeFactory({
                                            name: name, isNew: true
                                        }))
                                        this.wasNewNode.push(name)
                                    }
                                    else {
                                        nodes.update({ id: name, color: nodeColorFactory({}) })
                                    }
                                    if (!this.concepts.includes(name))this.concepts.push(name)
                                })
                                let newEdge = edgeFactory({
                                    from: triple.h_name,
                                    to: triple.t_name,
                                    label: triple.r_name,
                                    isNew: true
                                })
                                edges.add(newEdge)
                                this.wasNewEdge.push(newEdge.id)
                            }
                            else {
                                if (body.message) {
                                    this.$root.errorSnackBar.message = body.message
                                    this.$root.errorSnackBar.show = true
                                }
                                else {
                                    this.$root.errorSnackBar.message = 'Unexpected error when creating triple.'
                                    this.$root.errorSnackBar.show = true
                                }
                            }
                        })
                }
            },
            deleteTriple() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                if (this.$refs.tripleForm.validate()) {
                    this.$root.progress.show = true
                    fetch("{{ url_for('RESTful.triple') }}" + '{{ draftId }}', {
                        method: 'DELETE',
                        cache: 'no-store',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            h_name: this.h_name, r_name: this.r_name,
                            t_name: this.t_name,
                        })
                    })
                        .then(response => {
                            return response.json()
                        })
                        .then(body => {
                            this.$root.progress.show = false
                            if (body.triple) {
                                this.unselectAll()
                                let triple = body.triple
                                let id = edgeIdFromNames(triple.h_name, triple.r_name, triple.t_name)
                                edges.remove(id)
                                let nodeSet = new Set()
                                nodes.forEach(n => {
                                    if (edges.get({
                                        filter: (edge) => {
                                            return edge.from == n.id ||
                                                edge.to == n.id
                                        }
                                    }).length < 1) {
                                        console.log(n.id)
                                        nodes.update({ id: n.id, color: nodeColorFactory({ isTempory: true }) })
                                    }
                                })
                            }
                            else {
                                if (body.message) {
                                    this.$root.errorSnackBar.message = body.message
                                    this.$root.errorSnackBar.show = true
                                }
                                else {
                                    this.$root.errorSnackBar.message = 'Unexpected error when deleted triple.'
                                    this.$root.errorSnackBar.show = true
                                }
                            }
                        })
                }
            },
            removeUnreachable() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                fetch("{{ url_for('RESTful.unreachable') }}" + '{{ draftId }}', {
                    method: 'DELETE',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.triples) {
                            this.unselectAll()
                            body.triples.forEach(triple => {
                                let id = edgeIdFromNames(triple.h_name, triple.r_name, triple.t_name)
                                edges.remove(id);
                                [triple.h_name, triple.t_name].forEach(n => {
                                    if (edges.get({
                                        filter: (edge) => {
                                            return edge.from == n.id ||
                                                edge.to == n.id
                                        }
                                    }).length < 1) {
                                        console.log(n.id)
                                        nodes.remove(n.id)
                                    }
                                })

                            })
                        }
                        else {
                            if (body.message) {
                                this.$root.errorSnackBar.message = body.message
                                this.$root.errorSnackBar.show = true
                            }
                            else {
                                this.$root.errorSnackBar.message = 'Unexpected error when deleted triple.'
                                this.$root.errorSnackBar.show = true
                            }
                        }
                    })

            },
            unselectAll() {
                this.tripleBottomSheet = false
                this.clearForm()
                network.unselectAll()
            },
            clearForm() {
                this.h_name = ''
                this.r_name = ''
                this.t_name = ''
                this.$refs.tripleForm.resetValidation()
            },
            nodeFieldFocus(event) {
                this.focusing = event
                if (event == "head") {
                    try {
                        network.selectNodes([this.h_name], false)
                    }
                    catch {

                    }
                }
                else {
                    try {
                        network.selectNodes([this.t_name], false)
                    }
                    catch {

                    }
                }
            },
            nodeFieldChange(event) {
                try {
                    network.selectNodes([event], false)
                }
                catch {

                }
                this.isTripleExist()
            },
            edgeFieldChange(event) {
                this.isTripleExist()
            },
            isTripleExist() {
                network.unselectAll()
                if (this.h_name, this.r_name, this.t_name) {
                    let id = edgeIdFromNames(this.h_name, this.r_name, this.t_name)
                    try {
                        if (edges.get(id).length > 0) {
                            network.selectEdges([id])
                            this.isSelectingEdge = true
                        }
                        else{
                            this.isSelectingEdge = false
                        }

                    }
                    catch {
                        this.isSelectingEdge = false
                    }
                }
                else {
                    this.isSelectingEdge = false
                }
            },
            toggleStatus() {
                if (this.$root.progress.show == true) {
                    this.$root.bePatientSnackBar.show = true
                    return
                }
                this.$root.progress.show = true
                this.publishLoading = true
                fetch("{{ url_for('RESTful.setDraftStatus') }}/" + '{{ draftId }}', {
                    method: 'PUT',
                    cache: 'no-store',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status: this.publishSwitch ? "unpublished" : "published" })
                })
                    .then(response => {
                        return response.json()
                    })
                    .then(body => {
                        this.$root.progress.show = false
                        if (body.status) {
                            this.publishSwitch = body.status == "published"
                            this.publishLoading = false
                        }
                        else {
                            if (body.message) {
                                this.$root.errorSnackBar.message = body.message
                                this.$root.errorSnackBar.show = true
                            }
                            else {
                                this.$root.errorSnackBar.message = 'Unexpected error when deleted triple.'
                                this.$root.errorSnackBar.show = true
                            }
                        }
                    })
            },
            networkFit() {
                network.fit()
            }
        },
        created: function () {
            this.loadData()

        },
        template: '#content',
        delimiters: ['${', '}'],
    })
</script>
{% endblock %}